# Hands-On Exercises and Practical Activities

## ðŸ“‹ Overview

This document contains detailed hands-on exercises, practical activities, and interactive workshops for all four AI courses. Each exercise is designed to reinforce learning objectives through practical application and real-world problem solving.

---

## ðŸŽ¯ Course 1: AI Foundations (Beginner) - Hands-On Activities

### Lesson 1: AI Detective Hunt - Interactive Workshop

#### Activity 1: Personal AI Audit
**Duration:** 30 minutes  
**Participants:** Individual work, pairs sharing  
**Materials:** Smartphones, laptops, AI Discovery Worksheet

**Instructions:**
1. **Phase 1: Device Exploration (15 minutes)**
   - Open your smartphone and identify every app that uses AI
   - List AI features you use in each app
   - Rate how helpful each AI feature is (1-5 scale)
   - Note any AI features you didn't realize were AI

2. **Phase 2: Digital Life Mapping (15 minutes)**
   - Create a timeline of your typical day
   - Mark every interaction with AI systems
   - Calculate total time spent with AI assistance
   - Identify patterns in your AI usage

**AI Discovery Worksheet:**
```
My Personal AI Ecosystem:

MORNING ROUTINE:
â–¡ Smartphone alarm (smart wake-up timing)
â–¡ Weather app predictions
â–¡ News feed curation
â–¡ Traffic/navigation optimization
â–¡ Music/podcast recommendations

WORK/SCHOOL:
â–¡ Email smart filtering and suggestions
â–¡ Search engine results
â–¡ Auto-complete and spell check
â–¡ Translation tools
â–¡ Virtual assistants

ENTERTAINMENT:
â–¡ Streaming service recommendations
â–¡ Social media feeds
â–¡ Photo organization and editing
â–¡ Gaming AI opponents
â–¡ Advertisement targeting

EVENING:
â–¡ Smart home devices
â–¡ Online shopping recommendations
â–¡ Video call background effects
â–¡ Sleep tracking and optimization

REFLECTION QUESTIONS:
1. Which AI interaction surprised you most?
2. Which AI feature do you find most valuable?
3. Are there any AI systems you want to avoid or limit?
4. What AI capability do you wish existed?
```

#### Activity 2: AI Capability Challenge
**Duration:** 45 minutes  
**Format:** Team competition  
**Materials:** AI Challenge Cards, scoring sheets

**Game Format:**
Teams of 3-4 students compete in AI knowledge challenges:

**Round 1: AI or Not AI? (10 minutes)**
Teams decide if given scenarios involve AI:
- Netflix suggesting movies based on viewing history [AI]
- Calculator performing arithmetic [Not AI]
- Google Translate converting text between languages [AI]
- Digital thermostat maintaining set temperature [Not AI]
- Spotify creating personalized playlists [AI]

**Round 2: AI Application Matching (15 minutes)**
Match AI techniques to real-world applications:
- Computer Vision â†” Medical image analysis
- Natural Language Processing â†” Customer service chatbots
- Machine Learning â†” Credit card fraud detection
- Robotics â†” Manufacturing assembly lines
- Speech Recognition â†” Voice assistants

**Round 3: Future Prediction Challenge (20 minutes)**
Teams predict which AI capabilities will be common in 5 years:
- Fully autonomous vehicles
- AI personal tutors
- Automated medical diagnosis
- Real-time universal translation
- AI-generated entertainment content

**Scoring and Debrief:**
- Award points for accuracy and reasoning quality
- Discuss surprising answers and misconceptions
- Explore implications of predicted AI developments

### Lesson 2: AI Tools Exploration Lab

#### Activity 1: Voice Assistant Investigation
**Duration:** 25 minutes  
**Materials:** Various devices with voice assistants (Alexa, Siri, Google Assistant)

**Structured Testing Protocol:**
```
Voice Assistant Comparison Chart:

BASIC FUNCTIONALITY TEST:
Assistant: ____________

Simple Questions:
â–¡ "What's the weather today?" - Response Quality (1-5): ___
â–¡ "Set a timer for 5 minutes" - Accuracy (1-5): ___
â–¡ "What's 15% of 80?" - Correctness (1-5): ___

Complex Questions:
â–¡ "Explain quantum computing" - Helpfulness (1-5): ___
â–¡ "Plan a 3-day trip to Paris" - Usefulness (1-5): ___
â–¡ "What's the best restaurant nearby?" - Relevance (1-5): ___

Personality Tests:
â–¡ "Tell me a joke" - Entertainment Value (1-5): ___
â–¡ "How are you feeling today?" - Engagement (1-5): ___
â–¡ "What's your favorite color?" - Personality (1-5): ___

OBSERVATIONS:
Strengths: ________________
Weaknesses: ________________
Most Impressive Feature: ________________
Biggest Limitation: ________________
```

**Comparative Analysis:**
Students test the same questions across different assistants and compare:
- Response accuracy and completeness
- Personality and conversational style
- Integration with other services
- Privacy and data usage considerations

#### Activity 2: Image Recognition Challenge
**Duration:** 30 minutes  
**Materials:** Smartphones, variety of objects, Google Lens or similar apps

**Challenge Structure:**
1. **Easy Recognition Round (10 minutes)**
   - Common objects: book, coffee cup, car, flower
   - Test accuracy and speed of identification
   - Note additional information provided

2. **Medium Difficulty Round (10 minutes)**
   - Complex scenes: crowded restaurant, messy desk
   - Multiple objects in one image
   - Partially obscured items

3. **Hard Challenge Round (10 minutes)**
   - Abstract art or patterns
   - Handwriting recognition
   - Foreign language text
   - Damaged or unclear images

**Documentation Template:**
```
Image Recognition Results:

ROUND 1 - SIMPLE OBJECTS:
Object: _________ | Correctly Identified: Y/N | Additional Info: _________
Object: _________ | Correctly Identified: Y/N | Additional Info: _________

ROUND 2 - COMPLEX SCENES:
Scene: _________ | Objects Identified: ___/total | Accuracy: ___%

ROUND 3 - CHALLENGING IMAGES:
Challenge Type: _________ | Success: Y/N | AI Behavior: _________

REFLECTION:
- What types of images work best?
- What limitations did you discover?
- How might this technology improve?
- What privacy concerns do you have?
```

### Lesson 3: AI-Assisted Content Creation Workshop

#### Activity 1: Collaborative Story Writing with AI
**Duration:** 60 minutes  
**Materials:** Access to ChatGPT or similar text AI, shared document

**Creative Writing Process:**
1. **Setup Phase (10 minutes)**
   - Groups of 4 students select a story genre
   - Establish basic setting and main character
   - Define story goal (mystery to solve, adventure to complete, etc.)

2. **AI-Human Collaboration Rounds (40 minutes)**
   - **Round 1:** Human writes opening paragraph
   - **Round 2:** AI continues the story (students craft prompt)
   - **Round 3:** Human redirects plot based on AI output
   - **Round 4:** AI adds conflict or character development
   - **Round 5:** Human resolves story with AI assistance

3. **Editing and Refinement (10 minutes)**
   - Review complete story for coherence
   - Use AI for grammar and style improvements
   - Students make final creative decisions

**Prompt Engineering Guide:**
```
Effective AI Story Prompts:

BASIC STORY CONTINUATION:
"Continue this story in [genre] style: [previous text]"

ADDING SPECIFIC ELEMENTS:
"Continue this story and introduce a [character type/plot twist/setting change]: [previous text]"

STYLE MODIFICATION:
"Rewrite this paragraph in the style of [author/genre] while maintaining the plot: [text]"

CHARACTER DEVELOPMENT:
"Add dialogue and actions that reveal [character name]'s [personality trait]: [context]"

PROBLEM-SOLVING:
"Help resolve this plot problem in a creative way: [situation description]"
```

#### Activity 2: AI-Enhanced Presentation Creation
**Duration:** 75 minutes  
**Materials:** Canva AI tools, presentation topics list, laptops

**Project: "Future of Work" Presentation**

**Step 1: Research and Outline (20 minutes)**
- Use AI to research "Future of Work" trends
- Generate presentation outline with AI assistance
- Fact-check AI information with reliable sources

**Step 2: Content Development (25 minutes)**
- Create slide titles and main points
- Generate supporting statistics and examples
- Use AI for alternative explanations of complex concepts

**Step 3: Visual Design (20 minutes)**
- Use Canva's AI design suggestions
- Generate relevant images and icons
- Create consistent visual theme

**Step 4: Practice and Refinement (10 minutes)**
- Use AI to suggest presentation improvements
- Practice transitions and timing
- Prepare for Q&A with AI-generated potential questions

**AI Tool Usage Tracker:**
```
AI-Assisted Presentation Log:

RESEARCH PHASE:
AI Tool Used: _____________
Prompts Used:
1. _____________
2. _____________
Quality of Results (1-5): _____
Information Verified: Y/N

CONTENT CREATION:
AI Assistance Type: _____________
Original vs AI Content Ratio: ____%/____%
Editing/Refinement Needed (1-5): _____

VISUAL DESIGN:
AI Design Tools Used: _____________
Custom vs AI-Generated Images: ____%/____%
Design Coherence (1-5): _____

FINAL REFLECTION:
Most Helpful AI Feature: _____________
Biggest AI Limitation: _____________
Time Saved vs Traditional Method: ____% 
Quality Improvement (1-5): _____
```

### Lesson 4: AI Bias Detection Workshop

#### Activity 1: Bias Testing Laboratory
**Duration:** 50 minutes  
**Materials:** Various AI tools, bias testing prompts, analysis worksheets

**Systematic Bias Investigation:**

**Test 1: Language Model Bias (20 minutes)**
Use ChatGPT/Claude to complete these prompts and analyze responses:

```
Bias Testing Prompts:

GENDER BIAS:
1. "The nurse came to work and he/she..."
2. "The CEO announced that he/she..."
3. "The teacher told the students that he/she..."

RACIAL/CULTURAL BIAS:
1. "Describe a successful business leader"
2. "Write about a typical American family"
3. "Explain traditional holiday celebrations"

AGE BIAS:
1. "The job candidate was 55 years old and..."
2. "Young people today are..."
3. "Older workers in technology..."

RESPONSE ANALYSIS TEMPLATE:
Prompt: _________________
AI Response Summary: _________________
Potential Bias Detected: Y/N
Type of Bias: _________________
Evidence: _________________
Alternative Response Suggestion: _________________
```

**Test 2: Image Generation Bias (15 minutes)**
If available, test image AI tools:
- "Generate image of a doctor"
- "Create picture of a software engineer"
- "Show me a CEO in a boardroom"
- Analyze demographic representation in results

**Test 3: Search and Recommendation Bias (15 minutes)**
- Test search engines with identical queries from different accounts
- Examine recommendation algorithms for diversity
- Compare results across different platforms

#### Activity 2: Bias Mitigation Strategy Workshop
**Duration:** 45 minutes  
**Format:** Small groups developing solutions

**Challenge Scenarios:**
Groups receive real-world bias scenarios and develop solutions:

**Scenario 1: Hiring AI System**
"Your company's AI resume screening tool is rejecting qualified candidates from certain universities and backgrounds. How do you fix this?"

**Scenario 2: Loan Approval Algorithm**
"The bank's AI system is denying loans to qualified applicants in certain ZIP codes. What steps would you take?"

**Scenario 3: Medical Diagnostic AI**
"An AI diagnostic tool performs well for some demographic groups but poorly for others. How do you address this?"

**Solution Development Framework:**
```
Bias Mitigation Plan:

PROBLEM ANALYSIS:
- What bias is present?
- Who is being affected?
- What are the consequences?

ROOT CAUSE INVESTIGATION:
- Where did the bias originate?
- Is it in the data, algorithm, or application?
- What assumptions were made?

SOLUTION STRATEGIES:
- Data correction approaches
- Algorithm modifications
- Process improvements
- Monitoring and feedback systems

IMPLEMENTATION PLAN:
- Step-by-step implementation
- Success metrics
- Ongoing monitoring approach
- Stakeholder communication plan
```

### Lesson 5: Real-World Problem Solving Challenge

#### Activity 1: AI Solution Design Sprint
**Duration:** 90 minutes  
**Format:** Design thinking workshop with AI focus

**Problem Scenarios for Teams:**

**Scenario A: Small Restaurant Chain**
- Challenge: Inconsistent food quality across locations, high food waste, poor inventory management
- Resources: Point-of-sale data, supplier information, customer feedback
- Constraints: Limited budget ($10K), non-technical staff, must maintain personal touch

**Scenario B: Community Library System**
- Challenge: Declining visitor numbers, outdated catalog system, need for personalized recommendations
- Resources: Visitor data, book circulation records, community demographics
- Constraints: Public funding limitations, diverse user needs, privacy concerns

**Scenario C: Local Healthcare Clinic**
- Challenge: Long patient wait times, appointment no-shows, inefficient scheduling
- Resources: Historical appointment data, patient demographics, staff schedules
- Constraints: HIPAA compliance, limited IT infrastructure, patient privacy

**Design Sprint Process:**
```
90-Minute AI Solution Design Sprint:

PHASE 1: UNDERSTAND (20 minutes)
- Analyze the problem deeply
- Identify key stakeholders and their needs
- Map current process and pain points
- Define success criteria

PHASE 2: IDEATE (25 minutes)
- Brainstorm AI solutions (no limitations)
- Research available AI tools and services
- Consider implementation approaches
- Evaluate feasibility and impact

PHASE 3: PROTOTYPE (30 minutes)
- Create detailed solution description
- Map user journey with AI integration
- Design simple mockups or workflows
- Plan implementation phases

PHASE 4: TEST & REFINE (15 minutes)
- Present to another team for feedback
- Identify potential failure points
- Refine based on feedback
- Prepare final pitch
```

**Solution Documentation Template:**
```
AI Solution Proposal:

PROBLEM STATEMENT:
Clear description of the challenge we're solving

PROPOSED AI SOLUTION:
- AI technology/tools to be used
- How it integrates with existing processes
- User experience design
- Expected outcomes

IMPLEMENTATION PLAN:
Phase 1 (Month 1): ________________
Phase 2 (Month 2-3): ________________
Phase 3 (Month 4-6): ________________

RESOURCE REQUIREMENTS:
- Technology/software costs: $______
- Training and setup time: ______ hours
- Ongoing maintenance: ______ hours/month

SUCCESS METRICS:
- Primary success measure: ________________
- Secondary benefits: ________________
- Timeline for measurable results: ______

RISK MITIGATION:
- Potential challenges: ________________
- Backup plans: ________________
- Failure recovery: ________________
```

### Lesson 6: Final Project Workshop - Guided Creation Session

#### Activity 1: Project Planning and Setup
**Duration:** 30 minutes  
**Materials:** Project planning templates, AI tool accounts, laptops

**Project Selection Process:**
```
AI Project Decision Matrix:

Rate each project option (1-5 scale):

PERSONAL BRAND PACKAGE:
- Interest level: ____
- Skill match: ____
- Career relevance: ____
- Available time: ____
- Total Score: ____

SMALL BUSINESS LAUNCH KIT:
- Interest level: ____
- Skill match: ____
- Career relevance: ____
- Available time: ____
- Total Score: ____

CREATIVE CONTENT PORTFOLIO:
- Interest level: ____
- Skill match: ____
- Career relevance: ____
- Available time: ____
- Total Score: ____

LEARNING RESOURCE COLLECTION:
- Interest level: ____
- Skill match: ____
- Career relevance: ____
- Available time: ____
- Total Score: ____

Selected Project: ________________
Reason for Selection: ________________
```

**Project Planning Worksheet:**
```
AI Project Implementation Plan:

PROJECT OVERVIEW:
Title: ________________
Target Audience: ________________
Main Goal: ________________
Success Criteria: ________________

AI TOOLS SELECTION:
Primary AI Tool: ________ | Purpose: ________
Secondary AI Tool: ________ | Purpose: ________
Tertiary AI Tool: ________ | Purpose: ________
Quality Check Method: ________________

TIMELINE:
Week 1 Tasks: ________________
Week 2 Tasks: ________________
Final Week Tasks: ________________
Buffer Time: ________________

RESOURCE REQUIREMENTS:
Accounts Needed: ________________
Skills to Learn: ________________
Help Needed: ________________

QUALITY STANDARDS:
Professional appearance: Y/N
Error-free content: Y/N
AI attribution: Y/N
Original contribution: Y/N
```

#### Activity 2: Collaborative Work Session with Peer Support
**Duration:** 75 minutes  
**Format:** Structured work time with peer consultations

**Work Session Structure:**
- **Minutes 0-25:** Individual focused work on core project elements
- **Minutes 25-35:** Peer consultation round 1 (feedback on progress)
- **Minutes 35-60:** Individual work incorporating feedback
- **Minutes 60-70:** Peer consultation round 2 (quality review)
- **Minutes 70-75:** Final preparation and presentation setup

**Peer Consultation Framework:**
```
Peer Feedback Session:

PRESENTER: ________________
REVIEWER: ________________

PROJECT REVIEW:
1. What is the main goal of this project?
2. Who is the target audience?
3. What AI tools are being used and why?

FEEDBACK AREAS:
Quality (1-5): ____
Reason: ________________

Creativity (1-5): ____
Reason: ________________

AI Integration (1-5): ____
Reason: ________________

Professional Presentation (1-5): ____
Reason: ________________

SPECIFIC SUGGESTIONS:
1. One thing that's working really well:
________________

2. One area for improvement:
________________

3. Specific action suggestion:
________________

4. Additional resources that might help:
________________
```

---

## ðŸ”§ Course 2: Applied AI (Intermediate) - Hands-On Activities

### Lesson 1: Multi-Provider API Integration Lab

#### Activity 1: API Racing Challenge
**Duration:** 60 minutes  
**Materials:** API keys for OpenAI, Hugging Face, Google AI, coding environment

**Challenge Format:**
Teams compete to build the most robust API client that can handle multiple providers with graceful fallbacks.

**Competition Requirements:**
1. **Basic Functionality (20 points)**
   - Successfully call at least 2 different AI APIs
   - Return formatted responses
   - Handle basic errors

2. **Advanced Features (30 points)**
   - Implement automatic failover between providers
   - Add response time monitoring
   - Include cost tracking

3. **Code Quality (25 points)**
   - Clean, well-documented code
   - Proper error handling
   - Modular design

4. **Innovation (25 points)**
   - Creative features beyond requirements
   - Performance optimizations
   - User experience enhancements

**Starter Code Template:**
```python
import asyncio
import time
from typing import Dict, List, Optional
from dataclasses import dataclass

@dataclass
class APIResponse:
    content: str
    provider: str
    response_time: float
    tokens_used: int
    cost_estimate: float
    success: bool
    error_message: Optional[str] = None

class MultiProviderAIClient:
    def __init__(self, api_keys: Dict[str, str]):
        self.providers = {}
        self.usage_stats = {}
        self.setup_providers(api_keys)
    
    def setup_providers(self, api_keys: Dict[str, str]):
        """Initialize API clients for each provider"""
        # TODO: Initialize OpenAI, Anthropic, Google AI clients
        pass
    
    async def generate_text(self, 
                          prompt: str, 
                          max_tokens: int = 100,
                          preferred_provider: str = None) -> APIResponse:
        """
        Generate text using AI providers with automatic fallback
        """
        # TODO: Implement provider selection and fallback logic
        pass
    
    def get_usage_stats(self) -> Dict:
        """Return current usage statistics for all providers"""
        # TODO: Calculate and return usage statistics
        pass
    
    async def benchmark_providers(self, test_prompts: List[str]) -> Dict:
        """
        Benchmark response time and quality across providers
        """
        # TODO: Run comparative tests
        pass

# Challenge: Implement the missing methods
# Bonus: Add features like caching, rate limiting, cost optimization
```

**Testing Scenarios:**
```python
# Test cases for the API racing challenge
test_scenarios = [
    {
        "name": "Basic Text Generation",
        "prompt": "Explain quantum computing in simple terms",
        "expected_features": ["clear explanation", "simple language"],
        "test_all_providers": True
    },
    {
        "name": "Creative Writing", 
        "prompt": "Write a short story about a robot learning to paint",
        "expected_features": ["creativity", "narrative structure"],
        "test_all_providers": True
    },
    {
        "name": "Technical Documentation",
        "prompt": "Document this Python function: def factorial(n): return 1 if n <= 1 else n * factorial(n-1)",
        "expected_features": ["accurate description", "parameter explanation"],
        "test_all_providers": False
    },
    {
        "name": "Error Handling Test",
        "prompt": "A" * 10000,  # Intentionally long prompt to trigger errors
        "expected_behavior": "graceful error handling",
        "test_all_providers": True
    }
]
```

#### Activity 2: API Performance Lab
**Duration:** 45 minutes  
**Materials:** Performance testing tools, monitoring dashboards

**Performance Metrics Collection:**
Students build a comprehensive performance monitoring system:

```python
import asyncio
import time
import statistics
from collections import defaultdict

class APIPerformanceMonitor:
    def __init__(self):
        self.metrics = defaultdict(list)
        self.error_counts = defaultdict(int)
        
    async def timed_api_call(self, provider: str, api_call_func):
        """Time an API call and record metrics"""
        start_time = time.time()
        
        try:
            result = await api_call_func()
            response_time = time.time() - start_time
            
            self.metrics[f"{provider}_response_time"].append(response_time)
            self.metrics[f"{provider}_success"].append(1)
            
            return result
            
        except Exception as e:
            response_time = time.time() - start_time
            self.error_counts[provider] += 1
            self.metrics[f"{provider}_response_time"].append(response_time)
            self.metrics[f"{provider}_success"].append(0)
            
            raise e
    
    def generate_performance_report(self) -> Dict:
        """Generate comprehensive performance analytics"""
        report = {}
        
        for provider in ["openai", "anthropic", "google"]:
            response_times = self.metrics[f"{provider}_response_time"]
            successes = self.metrics[f"{provider}_success"]
            
            if response_times:
                report[provider] = {
                    "avg_response_time": statistics.mean(response_times),
                    "median_response_time": statistics.median(response_times),
                    "p95_response_time": sorted(response_times)[int(len(response_times) * 0.95)],
                    "success_rate": sum(successes) / len(successes) * 100,
                    "total_calls": len(response_times),
                    "error_count": self.error_counts[provider]
                }
        
        return report

# Performance testing challenge
async def run_performance_tests():
    monitor = APIPerformanceMonitor()
    
    # Test scenarios with different loads
    scenarios = [
        {"name": "Light Load", "concurrent_requests": 5, "total_requests": 50},
        {"name": "Medium Load", "concurrent_requests": 10, "total_requests": 100}, 
        {"name": "Heavy Load", "concurrent_requests": 20, "total_requests": 200}
    ]
    
    for scenario in scenarios:
        print(f"Running {scenario['name']} test...")
        # TODO: Implement load testing logic
        
    return monitor.generate_performance_report()
```

### Lesson 2: Advanced Data Processing Pipeline

#### Activity 1: Document Processing Challenge
**Duration:** 90 minutes  
**Materials:** Sample documents (PDF, Word, CSV, TXT), various libraries

**Multi-Format Document Processor:**
```python
import os
import pandas as pd
from pathlib import Path
from typing import List, Dict, Union
from dataclasses import dataclass

@dataclass
class ProcessedDocument:
    filename: str
    file_type: str
    raw_text: str
    cleaned_text: str
    metadata: Dict
    processing_time: float
    error_message: Optional[str] = None

class UniversalDocumentProcessor:
    def __init__(self):
        self.supported_formats = {
            '.pdf': self.process_pdf,
            '.docx': self.process_word,
            '.txt': self.process_text,
            '.csv': self.process_csv,
            '.json': self.process_json
        }
    
    def process_pdf(self, file_path: str) -> str:
        """Extract text from PDF files"""
        # TODO: Implement PDF text extraction
        # Consider: pdfplumber, PyMuPDF, or pdfminer
        pass
    
    def process_word(self, file_path: str) -> str:
        """Extract text from Word documents"""
        # TODO: Implement Word document processing
        # Consider: python-docx library
        pass
    
    def process_text(self, file_path: str) -> str:
        """Process plain text files"""
        # TODO: Handle encoding detection and text cleaning
        pass
    
    def process_csv(self, file_path: str) -> str:
        """Convert CSV to readable text format"""
        # TODO: Intelligently convert tabular data to text
        pass
    
    def process_json(self, file_path: str) -> str:
        """Convert JSON to readable text format"""
        # TODO: Flatten and convert JSON to readable format
        pass
    
    def clean_text(self, raw_text: str) -> str:
        """Clean and normalize extracted text"""
        # TODO: Implement text cleaning pipeline
        # - Remove extra whitespace
        # - Fix encoding issues  
        # - Normalize punctuation
        # - Remove metadata artifacts
        pass
    
    def extract_metadata(self, file_path: str, file_type: str) -> Dict:
        """Extract file metadata"""
        # TODO: Get file size, creation date, modification date
        # Format-specific metadata (author, title, etc.)
        pass
    
    async def process_document(self, file_path: str) -> ProcessedDocument:
        """Main processing method"""
        start_time = time.time()
        
        try:
            # Determine file type
            file_extension = Path(file_path).suffix.lower()
            
            if file_extension not in self.supported_formats:
                raise ValueError(f"Unsupported file format: {file_extension}")
            
            # Process file
            raw_text = self.supported_formats[file_extension](file_path)
            cleaned_text = self.clean_text(raw_text)
            metadata = self.extract_metadata(file_path, file_extension)
            
            processing_time = time.time() - start_time
            
            return ProcessedDocument(
                filename=Path(file_path).name,
                file_type=file_extension,
                raw_text=raw_text,
                cleaned_text=cleaned_text,
                metadata=metadata,
                processing_time=processing_time
            )
            
        except Exception as e:
            processing_time = time.time() - start_time
            return ProcessedDocument(
                filename=Path(file_path).name,
                file_type=file_extension,
                raw_text="",
                cleaned_text="",
                metadata={},
                processing_time=processing_time,
                error_message=str(e)
            )
```

**Challenge Tasks:**
1. **Basic Implementation (30 minutes)**
   - Implement at least 3 file format processors
   - Create basic text cleaning pipeline
   - Extract file metadata

2. **Quality Enhancement (30 minutes)**
   - Add intelligent text cleaning (remove headers/footers, fix formatting)
   - Implement encoding detection and handling
   - Add content quality scoring

3. **Advanced Features (30 minutes)**
   - Batch processing with progress tracking
   - Duplicate content detection
   - Automatic language detection
   - Content categorization

**Testing Dataset:**
Provide variety of challenging documents:
- Scanned PDF with OCR issues
- Word document with complex formatting
- CSV with mixed data types
- JSON with nested structures
- Text files in different encodings

#### Activity 2: Data Quality Assessment Workshop
**Duration:** 60 minutes  
**Materials:** Real-world datasets with quality issues

**Data Quality Metrics Implementation:**
```python
class DataQualityAnalyzer:
    def __init__(self):
        self.quality_metrics = {}
    
    def assess_completeness(self, data: List[str]) -> Dict:
        """Measure data completeness"""
        total_records = len(data)
        empty_records = len([d for d in data if not d.strip()])
        
        return {
            "completeness_ratio": (total_records - empty_records) / total_records,
            "total_records": total_records,
            "empty_records": empty_records,
            "quality_score": max(0, (total_records - empty_records) / total_records)
        }
    
    def assess_consistency(self, data: List[str]) -> Dict:
        """Measure data consistency and standardization"""
        # TODO: Implement consistency checks
        # - Formatting consistency
        # - Naming convention adherence  
        # - Data type consistency
        pass
    
    def assess_accuracy(self, data: List[str], validation_rules: Dict) -> Dict:
        """Assess data accuracy against validation rules"""
        # TODO: Implement accuracy validation
        # - Format validation (emails, phone numbers, dates)
        # - Range validation (numeric values)
        # - Reference data validation
        pass
    
    def detect_duplicates(self, data: List[str]) -> Dict:
        """Identify duplicate or near-duplicate content"""
        # TODO: Implement duplicate detection
        # - Exact duplicates
        # - Fuzzy matching for near-duplicates
        # - Semantic similarity detection
        pass
    
    def generate_quality_report(self, data: List[str]) -> Dict:
        """Generate comprehensive data quality report"""
        report = {
            "completeness": self.assess_completeness(data),
            "consistency": self.assess_consistency(data),
            "duplicates": self.detect_duplicates(data),
            "overall_score": 0  # Weighted combination of metrics
        }
        
        # Calculate overall quality score
        report["overall_score"] = (
            report["completeness"]["quality_score"] * 0.4 +
            report["consistency"]["quality_score"] * 0.3 +
            (1 - report["duplicates"]["duplicate_ratio"]) * 0.3
        )
        
        return report
```

### Lesson 3: AI-Powered Application Development

#### Activity 1: Full-Stack Application Sprint
**Duration:** 2 hours  
**Materials:** Web development environment, AI APIs

**Project: Smart Document Analyzer**
Build a complete web application that analyzes uploaded documents using AI.

**Architecture Requirements:**
```
Frontend (React/HTML):
- File upload interface with drag-and-drop
- Progress indicators for processing
- Results display with formatting
- Download/export functionality

Backend (Python Flask/FastAPI):
- File upload handling and validation
- Document processing pipeline
- AI service integration
- Results storage and retrieval

AI Integration:
- Text extraction from documents
- AI-powered summarization
- Sentiment analysis
- Key topic extraction
```

**Implementation Phases:**

**Phase 1: Backend Foundation (30 minutes)**
```python
from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import HTMLResponse
import asyncio
import uuid

app = FastAPI(title="Smart Document Analyzer")

# In-memory storage for demo (use database in production)
analysis_results = {}

@app.post("/analyze/")
async def analyze_document(file: UploadFile = File(...)):
    """Analyze uploaded document with AI"""
    
    # Validate file
    if file.content_type not in ["application/pdf", "text/plain", "application/msword"]:
        raise HTTPException(400, "Unsupported file type")
    
    # Generate analysis ID
    analysis_id = str(uuid.uuid4())
    
    try:
        # Read file content
        content = await file.read()
        
        # TODO: Process document (extract text, clean)
        text_content = extract_text(content, file.content_type)
        
        # TODO: AI analysis (summarization, sentiment, topics)
        analysis = await perform_ai_analysis(text_content)
        
        # Store results
        analysis_results[analysis_id] = {
            "filename": file.filename,
            "analysis": analysis,
            "status": "completed"
        }
        
        return {"analysis_id": analysis_id, "status": "completed", "results": analysis}
        
    except Exception as e:
        analysis_results[analysis_id] = {
            "filename": file.filename,
            "status": "error",
            "error": str(e)
        }
        raise HTTPException(500, f"Analysis failed: {str(e)}")

@app.get("/results/{analysis_id}")
async def get_results(analysis_id: str):
    """Retrieve analysis results"""
    if analysis_id not in analysis_results:
        raise HTTPException(404, "Analysis not found")
    
    return analysis_results[analysis_id]

async def perform_ai_analysis(text: str) -> dict:
    """Perform comprehensive AI analysis"""
    
    # TODO: Implement AI analysis pipeline
    # - Text summarization
    # - Sentiment analysis  
    # - Topic extraction
    # - Key phrase identification
    
    # Placeholder implementation
    return {
        "summary": "AI-generated summary here",
        "sentiment": {"score": 0.7, "label": "positive"},
        "topics": ["topic1", "topic2", "topic3"],
        "key_phrases": ["phrase1", "phrase2"]
    }
```

**Phase 2: Frontend Interface (45 minutes)**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Smart Document Analyzer</title>
    <style>
        .upload-area {
            border: 2px dashed #ccc;
            padding: 50px;
            text-align: center;
            cursor: pointer;
        }
        .upload-area.dragover {
            background-color: #f0f0f0;
        }
        .results {
            margin-top: 20px;
            padding: 20px;
            background: #f9f9f9;
        }
        .loading {
            display: none;
        }
    </style>
</head>
<body>
    <h1>Smart Document Analyzer</h1>
    
    <div id="upload-area" class="upload-area">
        <p>Drag and drop a document here, or click to select</p>
        <input type="file" id="file-input" style="display: none;" accept=".pdf,.txt,.docx">
    </div>
    
    <div id="loading" class="loading">
        <p>Analyzing document...</p>
        <progress></progress>
    </div>
    
    <div id="results" class="results" style="display: none;">
        <h2>Analysis Results</h2>
        <div id="results-content"></div>
    </div>

    <script>
        // TODO: Implement file upload and results display
        // - Drag and drop functionality
        // - File upload with progress
        // - Results display and formatting
        // - Error handling
        
        const uploadArea = document.getElementById('upload-area');
        const fileInput = document.getElementById('file-input');
        const loading = document.getElementById('loading');
        const results = document.getElementById('results');
        
        // Drag and drop handlers
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                uploadFile(files[0]);
            }
        });
        
        async function uploadFile(file) {
            // TODO: Implement file upload and analysis
        }
    </script>
</body>
</html>
```

**Phase 3: AI Integration (30 minutes)**
Complete the AI analysis pipeline with real API calls.

**Phase 4: Enhancement and Testing (15 minutes)**
Add error handling, improve UI, test with various documents.

#### Activity 2: Application Optimization Lab
**Duration:** 45 minutes  
**Materials:** Performance monitoring tools, optimization techniques

**Optimization Challenges:**
1. **Response Time Optimization**
   - Implement caching for repeated analyses
   - Add async processing for large documents
   - Optimize AI API calls

2. **User Experience Enhancement**
   - Add real-time progress updates
   - Implement result streaming
   - Create responsive design

3. **Error Handling Improvement**
   - Graceful degradation for API failures
   - User-friendly error messages
   - Retry mechanisms

---

## ðŸ’» Course 3: Web Development AI Apps - Hands-On Activities

### Lesson 1: Advanced React Patterns for AI

#### Activity 1: AI Hook Library Development
**Duration:** 90 minutes  
**Materials:** React development environment, TypeScript, AI APIs

**Challenge: Build Comprehensive AI Hook Library**

**Hook 1: useAI - Universal AI Integration**
```typescript
import { useState, useCallback, useRef } from 'react';

interface AIConfig {
  provider: 'openai' | 'anthropic' | 'google';
  model?: string;
  temperature?: number;
  maxTokens?: number;
}

interface AIResponse<T = any> {
  data: T | null;
  loading: boolean;
  error: string | null;
  usage?: {
    tokens: number;
    cost: number;
  };
}

export function useAI<T = any>(endpoint: string, config?: AIConfig) {
  const [response, setResponse] = useState<AIResponse<T>>({
    data: null,
    loading: false,
    error: null
  });
  
  const abortControllerRef = useRef<AbortController | null>(null);
  
  const execute = useCallback(async (payload: any) => {
    // Cancel previous request
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    
    abortControllerRef.current = new AbortController();
    
    setResponse(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const response = await fetch(`/api/${endpoint}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ...payload, ...config }),
        signal: abortControllerRef.current.signal
      });
      
      if (!response.ok) {
        throw new Error(`Request failed: ${response.statusText}`);
      }
      
      const data = await response.json();
      
      setResponse({
        data: data.result,
        loading: false,
        error: null,
        usage: data.usage
      });
      
    } catch (error) {
      if (error.name !== 'AbortError') {
        setResponse(prev => ({
          ...prev,
          loading: false,
          error: error.message
        }));
      }
    }
  }, [endpoint, config]);
  
  const cancel = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
  }, []);
  
  return { ...response, execute, cancel };
}
```

**Hook 2: useAIStream - Streaming Responses**
```typescript
import { useState, useCallback, useRef } from 'react';

interface StreamConfig {
  onChunk?: (chunk: string) => void;
  onComplete?: (fullResponse: string) => void;
  onError?: (error: string) => void;
}

export function useAIStream(endpoint: string, config?: StreamConfig) {
  const [content, setContent] = useState<string>('');
  const [isStreaming, setIsStreaming] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const readerRef = useRef<ReadableStreamDefaultReader | null>(null);
  
  const startStream = useCallback(async (payload: any) => {
    setIsStreaming(true);
    setContent('');
    setError(null);
    
    try {
      const response = await fetch(`/api/${endpoint}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      
      if (!response.ok || !response.body) {
        throw new Error('Streaming not supported');
      }
      
      const reader = response.body.getReader();
      readerRef.current = reader;
      const decoder = new TextDecoder();
      
      let fullContent = '';
      
      while (true) {
        const { done, value } = await reader.read();
        
        if (done) break;
        
        const chunk = decoder.decode(value, { stream: true });
        fullContent += chunk;
        
        setContent(fullContent);
        config?.onChunk?.(chunk);
      }
      
      config?.onComplete?.(fullContent);
      
    } catch (err) {
      const errorMsg = err.message;
      setError(errorMsg);
      config?.onError?.(errorMsg);
    } finally {
      setIsStreaming(false);
    }
  }, [endpoint, config]);
  
  const stopStream = useCallback(() => {
    if (readerRef.current) {
      readerRef.current.cancel();
    }
    setIsStreaming(false);
  }, []);
  
  return {
    content,
    isStreaming,
    error,
    startStream,
    stopStream
  };
}
```

**Hook 3: useAIConversation - Chat Management**
```typescript
interface Message {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
  metadata?: any;
}

interface ConversationState {
  messages: Message[];
  loading: boolean;
  error: string | null;
}

export function useAIConversation(sessionId?: string) {
  const [state, setState] = useState<ConversationState>({
    messages: [],
    loading: false,
    error: null
  });
  
  const addMessage = useCallback((message: Omit<Message, 'id' | 'timestamp'>) => {
    const newMessage: Message = {
      ...message,
      id: Date.now().toString(),
      timestamp: new Date()
    };
    
    setState(prev => ({
      ...prev,
      messages: [...prev.messages, newMessage]
    }));
    
    return newMessage.id;
  }, []);
  
  const sendMessage = useCallback(async (content: string) => {
    const userMessageId = addMessage({ role: 'user', content });
    
    setState(prev => ({ ...prev, loading: true, error: null }));
    
    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: content,
          sessionId,
          history: state.messages
        })
      });
      
      const data = await response.json();
      
      addMessage({
        role: 'assistant',
        content: data.message,
        metadata: data.metadata
      });
      
    } catch (error) {
      setState(prev => ({ ...prev, error: error.message }));
    } finally {
      setState(prev => ({ ...prev, loading: false }));
    }
  }, [addMessage, sessionId, state.messages]);
  
  const clearConversation = useCallback(() => {
    setState({
      messages: [],
      loading: false,
      error: null
    });
  }, []);
  
  return {
    ...state,
    sendMessage,
    addMessage,
    clearConversation
  };
}
```

**Testing Challenge:**
Create test components that demonstrate each hook's capabilities:

1. **AI Text Generator using useAI**
2. **Real-time Chat using useAIStream**
3. **Conversation Manager using useAIConversation**

#### Activity 2: Component Architecture Workshop
**Duration:** 60 minutes  
**Materials:** Component design tools, React development environment

**Challenge: Design AI Component System**
Students design and implement a comprehensive component architecture for AI applications.

**Component Hierarchy Design:**
```
AIApplication
â”œâ”€â”€ AIProvider (Context)
â”œâ”€â”€ AIChat
â”‚   â”œâ”€â”€ MessageList
â”‚   â”‚   â”œâ”€â”€ UserMessage
â”‚   â”‚   â”œâ”€â”€ AssistantMessage
â”‚   â”‚   â””â”€â”€ SystemMessage
â”‚   â”œâ”€â”€ MessageInput
â”‚   â””â”€â”€ TypingIndicator
â”œâ”€â”€ AIDocumentProcessor
â”‚   â”œâ”€â”€ FileUpload
â”‚   â”œâ”€â”€ ProcessingStatus
â”‚   â””â”€â”€ ResultsDisplay
â””â”€â”€ AISettings
    â”œâ”€â”€ ProviderSelector
    â”œâ”€â”€ ModelConfiguration
    â””â”€â”€ UsageTracker
```

### Lesson 2: Production Backend Development

#### Activity 1: Scalable API Architecture Challenge
**Duration:** 2 hours  
**Materials:** FastAPI/Express, database, Redis, monitoring tools

**Challenge: Build Production-Ready AI API**

**Requirements:**
- Handle 1000+ concurrent requests
- Support multiple AI providers with fallback
- Implement caching and rate limiting
- Include monitoring and alerting
- Provide comprehensive API documentation

**Architecture Implementation:**

**FastAPI Version:**
```python
from fastapi import FastAPI, Depends, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
import redis
import asyncio
from sqlalchemy.orm import Session
import logging

app = FastAPI(
    title="Production AI API",
    description="Scalable AI service with multiple provider support",
    version="1.0.0"
)

# Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure appropriately for production
    allow_methods=["*"],
    allow_headers=["*"],
)
app.add_middleware(GZipMiddleware, minimum_size=1000)

# Redis for caching and rate limiting
redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)

# Rate limiting decorator
def rate_limit(requests_per_minute: int = 60):
    def decorator(func):
        async def wrapper(request, *args, **kwargs):
            client_ip = request.client.host
            key = f"rate_limit:{client_ip}"
            
            current = redis_client.get(key)
            if current and int(current) >= requests_per_minute:
                raise HTTPException(429, "Rate limit exceeded")
            
            redis_client.incr(key)
            redis_client.expire(key, 60)
            
            return await func(request, *args, **kwargs)
        return wrapper
    return decorator

# Caching decorator
def cache_response(ttl: int = 300):
    def decorator(func):
        async def wrapper(*args, **kwargs):
            # Generate cache key from function args
            cache_key = f"cache:{func.__name__}:{hash(str(args) + str(kwargs))}"
            
            # Try to get from cache
            cached = redis_client.get(cache_key)
            if cached:
                return json.loads(cached)
            
            # Execute function and cache result
            result = await func(*args, **kwargs)
            redis_client.setex(cache_key, ttl, json.dumps(result))
            
            return result
        return wrapper
    return decorator

class AIProviderManager:
    def __init__(self):
        self.providers = {
            'openai': OpenAIProvider(),
            'anthropic': AnthropicProvider(),
            'google': GoogleProvider()
        }
        self.fallback_order = ['openai', 'anthropic', 'google']
    
    async def generate_with_fallback(self, prompt: str, config: dict):
        """Try providers in fallback order until success"""
        last_error = None
        
        for provider_name in self.fallback_order:
            try:
                provider = self.providers[provider_name]
                result = await provider.generate(prompt, config)
                
                # Log successful provider
                logging.info(f"Successfully used provider: {provider_name}")
                
                return {
                    "content": result,
                    "provider": provider_name,
                    "fallback_used": provider_name != self.fallback_order[0]
                }
                
            except Exception as e:
                logging.warning(f"Provider {provider_name} failed: {str(e)}")
                last_error = e
                continue
        
        # All providers failed
        raise HTTPException(503, f"All AI providers unavailable: {str(last_error)}")

# Global provider manager
ai_manager = AIProviderManager()

@app.post("/api/generate")
@rate_limit(100)  # 100 requests per minute
@cache_response(600)  # Cache for 10 minutes
async def generate_text(request: GenerateRequest, background_tasks: BackgroundTasks):
    """Generate text using AI with automatic fallback"""
    
    try:
        result = await ai_manager.generate_with_fallback(
            request.prompt,
            request.config
        )
        
        # Background task to log usage
        background_tasks.add_task(log_usage, request, result)
        
        return result
        
    except Exception as e:
        logging.error(f"Generation failed: {str(e)}")
        raise HTTPException(500, "Generation service unavailable")

async def log_usage(request, result):
    """Log API usage for analytics"""
    # TODO: Implement usage logging to database
    pass

# Health check endpoint
@app.get("/health")
async def health_check():
    """Comprehensive health check"""
    health_status = {
        "status": "healthy",
        "providers": {},
        "cache": False,
        "database": False
    }
    
    # Check each AI provider
    for name, provider in ai_manager.providers.items():
        try:
            await provider.health_check()
            health_status["providers"][name] = "healthy"
        except:
            health_status["providers"][name] = "unhealthy"
    
    # Check Redis
    try:
        redis_client.ping()
        health_status["cache"] = True
    except:
        health_status["cache"] = False
    
    # TODO: Check database connection
    
    # Determine overall status
    if not any(health_status["providers"].values()):
        health_status["status"] = "unhealthy"
        raise HTTPException(503, health_status)
    
    return health_status

# Metrics endpoint
@app.get("/metrics")
async def get_metrics():
    """Prometheus-compatible metrics"""
    # TODO: Implement comprehensive metrics
    pass
```

#### Activity 2: Database Design and Optimization
**Duration:** 45 minutes  
**Materials:** PostgreSQL, SQLAlchemy, database design tools

**Challenge: Design Optimal Database Schema**

Students design database schema for AI application with performance optimization:

```sql
-- Optimized database schema for AI applications

-- Users table with indexing
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(255) NOT NULL,
    tier VARCHAR(50) DEFAULT 'free', -- free, pro, enterprise
    api_key VARCHAR(255) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- AI conversations with partitioning by date
CREATE TABLE conversations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255),
    provider VARCHAR(50) NOT NULL,
    model VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (created_at);

-- Create monthly partitions
CREATE TABLE conversations_2024_01 PARTITION OF conversations
    FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

-- Messages table with efficient storage
CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    conversation_id UUID REFERENCES conversations(id) ON DELETE CASCADE,
    role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
    content TEXT NOT NULL,
    tokens_used INTEGER DEFAULT 0,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Usage tracking for billing and analytics
CREATE TABLE usage_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    provider VARCHAR(50) NOT NULL,
    model VARCHAR(100) NOT NULL,
    operation VARCHAR(50) NOT NULL,
    tokens_input INTEGER NOT NULL,
    tokens_output INTEGER NOT NULL,
    cost_usd DECIMAL(10, 6) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) PARTITION BY RANGE (created_at);

-- API usage tracking
CREATE TABLE api_requests (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    endpoint VARCHAR(255) NOT NULL,
    method VARCHAR(10) NOT NULL,
    response_code INTEGER NOT NULL,
    response_time_ms INTEGER NOT NULL,
    ip_address INET,
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Performance-optimized indexes
CREATE INDEX idx_conversations_user_created ON conversations(user_id, created_at DESC);
CREATE INDEX idx_messages_conversation_created ON messages(conversation_id, created_at);
CREATE INDEX idx_usage_logs_user_date ON usage_logs(user_id, created_at DESC);
CREATE INDEX idx_api_requests_user_date ON api_requests(user_id, created_at DESC);

-- JSONB indexes for metadata queries
CREATE INDEX idx_messages_metadata ON messages USING GIN (metadata);

-- Materialized view for usage analytics
CREATE MATERIALIZED VIEW daily_usage_summary AS
SELECT 
    user_id,
    DATE(created_at) as usage_date,
    provider,
    COUNT(*) as request_count,
    SUM(tokens_input + tokens_output) as total_tokens,
    SUM(cost_usd) as total_cost
FROM usage_logs 
GROUP BY user_id, DATE(created_at), provider;

-- Refresh schedule for materialized view
CREATE UNIQUE INDEX ON daily_usage_summary (user_id, usage_date, provider);
```

---

## ðŸ¢ Course 4: Enterprise AI Business - Hands-On Activities

### Lesson 1: Strategic AI Analysis Workshop

#### Activity 1: Industry AI Maturity Assessment
**Duration:** 90 minutes  
**Materials:** Industry research tools, competitive analysis templates

**Challenge: Complete Industry Analysis**
Executive teams conduct comprehensive analysis of AI adoption in their industry.

**AI Maturity Framework:**
```
Industry AI Maturity Assessment:

LEVEL 1 - EXPERIMENTING (Score: 1-2)
â–¡ Pilot projects and proof-of-concepts
â–¡ Limited organizational commitment
â–¡ No clear AI strategy or roadmap
â–¡ Minimal investment in AI capabilities
â–¡ Ad-hoc approach to AI implementation

LEVEL 2 - DEVELOPING (Score: 3-4)  
â–¡ Multiple AI use cases in development
â–¡ Dedicated AI team or resources
â–¡ Basic AI governance and policies
â–¡ Some successful implementations
â–¡ Beginning to scale AI initiatives

LEVEL 3 - SCALING (Score: 5-6)
â–¡ AI embedded in core business processes
â–¡ Comprehensive AI strategy and roadmap
â–¡ Strong AI governance framework
â–¡ Measurable business impact from AI
â–¡ Cross-functional AI integration

LEVEL 4 - OPTIMIZING (Score: 7-8)
â–¡ AI-first culture and decision making
â–¡ Advanced AI capabilities and custom models
â–¡ Continuous optimization and innovation
â–¡ Industry leadership in AI adoption
â–¡ Strategic competitive advantage from AI

LEVEL 5 - TRANSFORMING (Score: 9-10)
â–¡ AI fundamentally reshapes business model
â–¡ Industry-leading AI innovations
â–¡ AI-driven new products and services
â–¡ Ecosystem and platform strategies
â–¡ Setting industry standards for AI

ASSESSMENT PROCESS:
1. Rate your industry overall: ____/10
2. Rate your organization: ____/10
3. Rate top 3 competitors:
   - Competitor 1: ____/10
   - Competitor 2: ____/10  
   - Competitor 3: ____/10
4. Identify maturity gap: ____
5. Strategic implications: ________________
```

**Competitive Intelligence Framework:**
```python
class CompetitiveAIAnalysis:
    def __init__(self, industry: str):
        self.industry = industry
        self.competitors = []
        self.analysis_results = {}
    
    def analyze_competitor(self, company_name: str) -> dict:
        """Analyze competitor's AI initiatives"""
        
        analysis = {
            "company": company_name,
            "ai_initiatives": [],
            "technology_stack": [],
            "partnerships": [],
            "investment_level": "",
            "competitive_advantage": [],
            "vulnerabilities": [],
            "strategic_focus": ""
        }
        
        # Data collection sources
        sources = [
            "Public announcements and press releases",
            "SEC filings and investor calls",
            "Job postings for AI roles",
            "Patent filings and research papers",
            "Technology partnerships and acquisitions",
            "Product features and capabilities",
            "Customer case studies and testimonials"
        ]
        
        # TODO: Implement data collection from various sources
        # This would integrate with web scraping, API calls, etc.
        
        return analysis
    
    def generate_competitive_matrix(self) -> dict:
        """Create comprehensive competitive comparison"""
        
        matrix = {
            "dimensions": [
                "AI Investment Level",
                "Technology Sophistication", 
                "Market Adoption",
                "Innovation Speed",
                "Strategic Focus",
                "Competitive Differentiation"
            ],
            "competitors": {},
            "market_leaders": [],
            "strategic_gaps": [],
            "opportunities": []
        }
        
        # TODO: Populate matrix with competitor analysis
        
        return matrix
    
    def identify_strategic_opportunities(self) -> list:
        """Identify strategic opportunities based on competitive analysis"""
        
        opportunities = [
            {
                "type": "Market Gap",
                "description": "Underserved market segment or use case",
                "priority": "High/Medium/Low",
                "investment_required": "Low/Medium/High",
                "time_to_market": "3-6 months",
                "competitive_advantage": "First mover advantage"
            }
        ]
        
        return opportunities
```

#### Activity 2: ROI Calculator Workshop
**Duration:** 60 minutes  
**Materials:** Excel/Google Sheets, ROI calculation templates

**Advanced ROI Modeling Challenge:**
Build comprehensive financial model that accounts for:

1. **Implementation Costs**
   - Technology licensing and subscriptions
   - Professional services and consulting
   - Internal resource allocation
   - Training and change management
   - Infrastructure and integration costs

2. **Operational Costs**
   - Ongoing software subscriptions
   - Maintenance and support
   - Additional staffing requirements
   - Monitoring and governance costs

3. **Benefits Quantification**
   - Direct cost savings (labor, efficiency)
   - Revenue generation (new products, improved sales)
   - Risk mitigation value
   - Quality improvements
   - Customer satisfaction improvements

4. **Risk Adjustments**
   - Implementation risk factors
   - Technology risk considerations
   - Market adoption uncertainties
   - Regulatory and compliance risks

**Excel ROI Model Template:**
```
AI Investment ROI Calculator:

INPUTS SECTION:
- Organization Size: [Small/Medium/Large/Enterprise]
- Industry: [Select from dropdown]
- Primary Use Case: [Select from list]
- Implementation Timeline: [6-36 months]
- Risk Tolerance: [Conservative/Moderate/Aggressive]

COST CALCULATIONS:
Year 0 (Implementation):
- Software Licensing: $____
- Professional Services: $____
- Hardware/Infrastructure: $____
- Training Programs: $____
- Change Management: $____
- Contingency (10-20%): $____
Total Year 0: $____

Years 1-5 (Operational):
- Annual Software Costs: $____
- Support and Maintenance: $____
- Additional FTE Costs: $____
- Ongoing Training: $____
- Governance and Compliance: $____
Total Annual Operational: $____

BENEFITS CALCULATIONS:
Direct Cost Savings:
- Labor Cost Reduction: $____ per year
- Efficiency Improvements: $____ per year
- Error Reduction Savings: $____ per year

Revenue Generation:
- New Product Revenue: $____ per year
- Improved Sales Performance: $____ per year
- Customer Retention Value: $____ per year

Soft Benefits (Estimated Value):
- Improved Decision Making: $____
- Risk Mitigation: $____
- Competitive Advantage: $____

RISK ADJUSTMENTS:
- Implementation Risk Factor: ___%
- Technology Risk Factor: ___%
- Market Risk Factor: ___%
- Overall Risk Adjustment: ___%

FINANCIAL METRICS:
- Net Present Value (NPV): $____
- Internal Rate of Return (IRR): ___%
- Payback Period: ____ months
- Return on Investment: ___%
- Risk-Adjusted ROI: ___%

SCENARIO ANALYSIS:
Conservative Case: ROI = ___%
Most Likely Case: ROI = ___%
Optimistic Case: ROI = ___%
```

### Lesson 2: Risk Management and Compliance Workshop

#### Activity 1: AI Risk Assessment Matrix
**Duration:** 75 minutes  
**Materials:** Risk assessment templates, regulatory compliance checklists

**Comprehensive Risk Assessment Exercise:**

**Risk Categories and Assessment:**
```
AI Risk Assessment Framework:

TECHNICAL RISKS:
1. Model Performance Degradation
   - Impact: High/Medium/Low
   - Probability: High/Medium/Low  
   - Risk Score: ____
   - Mitigation Strategy: ________________

2. Data Quality and Bias Issues
   - Impact: ____
   - Probability: ____
   - Risk Score: ____
   - Mitigation Strategy: ________________

3. Security and Privacy Breaches
   - Impact: ____
   - Probability: ____
   - Risk Score: ____
   - Mitigation Strategy: ________________

OPERATIONAL RISKS:
4. Over-reliance on AI Systems
   - Impact: ____
   - Probability: ____
   - Risk Score: ____
   - Mitigation Strategy: ________________

5. Integration and Compatibility Issues
   - Impact: ____
   - Probability: ____
   - Risk Score: ____
   - Mitigation Strategy: ________________

BUSINESS RISKS:
6. Regulatory and Compliance Violations
   - Impact: ____
   - Probability: ____
   - Risk Score: ____
   - Mitigation Strategy: ________________

7. Competitive Disadvantage
   - Impact: ____
   - Probability: ____
   - Risk Score: ____
   - Mitigation Strategy: ________________

STRATEGIC RISKS:
8. Misalignment with Business Objectives
   - Impact: ____
   - Probability: ____
   - Risk Score: ____
   - Mitigation Strategy: ________________
```

**Risk Mitigation Planning Workshop:**
Teams develop comprehensive risk mitigation strategies:

1. **Prevention Strategies**: Measures to prevent risks from occurring
2. **Detection Strategies**: Systems to identify risks early
3. **Response Strategies**: Actions to take when risks occur
4. **Recovery Strategies**: Plans to restore normal operations

#### Activity 2: Compliance Framework Design
**Duration:** 45 minutes  
**Materials:** Regulatory requirements, compliance templates

**Regulatory Compliance Mapping:**
Map AI use cases to applicable regulations and compliance requirements:

```
Compliance Requirement Matrix:

GDPR (EU General Data Protection Regulation):
Applicable Use Cases: ________________
Key Requirements:
â–¡ Lawful basis for processing
â–¡ Data subject consent management
â–¡ Right to explanation implementation
â–¡ Data portability capabilities
â–¡ Privacy by design principles

Implementation Status: Not Started/In Progress/Completed
Compliance Gaps: ________________
Action Plan: ________________

CCPA (California Consumer Privacy Act):
Applicable Use Cases: ________________
Key Requirements:
â–¡ Consumer privacy rights disclosure
â–¡ Opt-out mechanisms for data selling
â–¡ Personal information inventory
â–¡ Consumer request processing

Implementation Status: ________________
Compliance Gaps: ________________
Action Plan: ________________

EU AI Act:
Applicable Use Cases: ________________
Risk Classification: High/Limited/Minimal/Unacceptable
Key Requirements:
â–¡ Risk assessment documentation
â–¡ Quality management systems
â–¡ Transparency and disclosure
â–¡ Human oversight mechanisms

Implementation Status: ________________
Compliance Gaps: ________________
Action Plan: ________________

Industry-Specific Regulations:
Regulation: ________________
Applicable Use Cases: ________________
Key Requirements: ________________
Implementation Status: ________________
```

### Lesson 3: Change Management Simulation

#### Activity 1: AI Transformation Simulation
**Duration:** 2 hours  
**Materials:** Role-playing scenarios, change management frameworks

**Simulation Setup:**
Participants assume different organizational roles in an AI transformation scenario:

**Roles:**
- CEO/Senior Executive
- IT Director
- HR Director
- Operations Manager
- Front-line Manager
- Employee Representative
- Union Representative (if applicable)
- Customer Representative

**Simulation Scenario:**
"MidSize Manufacturing Company implementing AI-powered predictive maintenance system affecting 200+ maintenance workers and plant operations."

**Simulation Phases:**

**Phase 1: Initial Announcement (30 minutes)**
- CEO announces AI transformation initiative
- Each role responds based on their perspective
- Document initial reactions and concerns

**Phase 2: Stakeholder Concerns (45 minutes)**
- Each role presents their concerns and requirements
- Negotiate solutions and compromises
- Identify critical success factors

**Phase 3: Implementation Planning (30 minutes)**
- Develop implementation approach addressing concerns
- Create communication and training plans
- Establish success metrics and timelines

**Phase 4: Crisis Management (15 minutes)**
- Introduce unexpected challenges (e.g., system failures, employee resistance)
- Practice crisis response and adaptation
- Evaluate decision-making processes

**Debrief and Learning (20 minutes)**
- Analyze what worked well and what didn't
- Extract key lessons for real-world application
- Identify best practices for change management

**Change Management Assessment:**
```
Simulation Performance Evaluation:

STAKEHOLDER ENGAGEMENT:
- Identification of key stakeholders: Excellent/Good/Poor
- Understanding of stakeholder concerns: ___/___/___
- Effectiveness of communication: ___/___/___
- Building consensus and buy-in: ___/___/___

PLANNING AND EXECUTION:
- Comprehensiveness of implementation plan: ___/___/___
- Realistic timeline and resource allocation: ___/___/___
- Risk assessment and mitigation: ___/___/___
- Flexibility and adaptation: ___/___/___

LEADERSHIP AND DECISION-MAKING:
- Leadership presence and communication: ___/___/___
- Decision-making under pressure: ___/___/___
- Collaboration and team building: ___/___/___
- Problem-solving effectiveness: ___/___/___

KEY LEARNINGS:
1. Most important insight: ________________
2. Biggest challenge faced: ________________
3. What would you do differently? ________________
4. Application to your organization: ________________
```

---

## ðŸ“š Instructor Resources and Guidelines

### Activity Facilitation Best Practices

#### Pre-Activity Preparation
1. **Technical Setup Verification**
   - Test all tools and platforms 24 hours before
   - Prepare backup plans for technical failures
   - Create shared resources and templates
   - Set up collaboration tools and accounts

2. **Material Preparation**
   - Print physical handouts as backups
   - Create digital resource folders
   - Prepare example solutions and demonstrations
   - Set up screen sharing and recording capabilities

#### During Activity Facilitation
1. **Energy and Engagement**
   - Start activities with clear objectives and energy
   - Circulate actively to support and encourage
   - Celebrate progress and successes publicly
   - Address frustrations quickly and positively

2. **Learning Support**
   - Provide just-in-time assistance
   - Encourage peer-to-peer learning
   - Ask probing questions to deepen understanding
   - Connect activities to real-world applications

#### Post-Activity Debrief
1. **Reflection and Synthesis**
   - Facilitate group discussion of key learnings
   - Connect activity outcomes to course objectives
   - Address misconceptions and questions
   - Preview upcoming applications

2. **Assessment Integration**
   - Collect formative assessment data
   - Provide immediate feedback when possible
   - Document student progress and challenges
   - Plan follow-up activities based on outcomes

### Differentiation Strategies

#### For Advanced Students
- Provide extension challenges and bonus activities
- Offer mentoring opportunities with struggling peers
- Include advanced technical concepts and optimizations
- Encourage innovation and creative problem-solving

#### For Struggling Students
- Provide additional scaffolding and support
- Create simplified versions of complex activities
- Offer one-on-one assistance and guidance
- Connect to peer support networks and resources

#### For Different Learning Styles
- **Visual Learners**: Diagrams, flowcharts, visual demonstrations
- **Auditory Learners**: Discussion, explanation, verbal processing
- **Kinesthetic Learners**: Hands-on activities, physical interaction
- **Reading/Writing Learners**: Documentation, reflection, written analysis

### Assessment Integration

#### Formative Assessment Opportunities
- Real-time observation during activities
- Quick check-ins and progress monitoring
- Peer feedback and self-reflection
- Exit tickets and brief surveys

#### Summative Assessment Connections
- Activity artifacts as portfolio evidence
- Performance during activities as assessment data
- Peer evaluations and collaboration skills
- Application of learning to future projects

---

*These comprehensive hands-on activities provide students with practical, engaging experiences that reinforce learning objectives while building real-world applicable skills in AI development, implementation, and strategic planning.*